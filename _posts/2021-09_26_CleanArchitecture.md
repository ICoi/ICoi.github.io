---
layout: post
title: "Book Review - Clean Architecture"
author: "Daun Joung"
tags: ["CleanArchitecture","BookReview"]
---
# 책 리뷰 - Clean Architecture
* 이 글은 Clearn ARchitecture 책의 내용 일부를 발최하여 작성하였습니다. 자세한 설명 및 내용은 도서를 참고하시면 됩니다.


# 1부. 소개

## 1장 설계와 아키텍처란?
* 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는 데 있다.
* 투입 직원수↑  ➢  생산성은 일정 수준에 수렴함 ➢ 투입 대비 생산성↓
  ➢ 아키텍처 존재시 엉망으로 만들 때 보다 생산성↑
  
## 2장 두가지 가치에 대한 이야기
### 가치 1. 행위(Behavior)
* 프로그래머는 이해 관계자가 기능 명세서나 요구사항 문서를 구체화 할 수 있도록 도움. 
* 또한, 이러한 요구사항을 만족하도록 코드 작성.
### 가치 2. 아키텍처(Architecture)
* '소프트(Soft) 웨어' - 기계의 행위를 Soft(쉽게) 변경 할 수 있어야 함
* 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는게 더 힘들어짐
* 아키텍처는 형태에 독립적이여야 하고, 그럴수록 더 실용적이다.


행위(Behavior) < 아키텍처(Architecture) : 아키텍처가 후순위가 되면 시스템 개발비용↑, 혹은 기능변경이 불가능 해 질 수도


# 2부. 벽돌부터 시작하기: 프로그래밍 패러다임
## 3장. 패러다임 개요
* 패러다임이란?
  * 프로그래밍을 하는 방법. 어떤 프로그래밍 구조를 사용할지, 언제 구조를 사용해야 하는지 결정
  * 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 대해 규칙을 부과 (if/while과 같은 제어, 반복문 활용)
  * 객체 지향 프로그래밍 : 제어흐름의 간접적인 전환에 대해 규칙을 부과
  * 함수형 프로그래밍 : 할당문에 대해 규칙 부과 (변수 할당에 부과되는 규율)
  패러다임은 무엇을 해야 할 지 보다는 무엇을 해서는 안되는지를 말해준다.
  
## 4장. 구조적 프로그래밍
<pre>
* 분기, 반복(if, while)이라는 단순 제어 + 순차 실행 (sequential execution) ➢ 특별한 장점
                    ⍒
  복잡한 요구사항을 더 작은 기능 단위로 분해.
  대규모 시스템 → 모듈과 컴포넌트 → 입증 할 수 있는 아주 작은 기능으로 세분화
                    ⍒
테스트를 통해 버그가 없음을 증명 ➢ 안정적인 서비스 제공
</pre>

## 5장. 객체지향 프로그래밍
* OO(Object-Oriented) 본질 : 캡슐화, 상속, **다형성⭐︎**

* 다형성 </br>
   ⤷ 의존성 역전(dependency inversion) : 소프트웨어 아키텍트는 시스템의 소스코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적 권한 갖게 됨 </br>
      ⤷ 기능컴포넌트 독립을 통해 '배포 독립성', '개발 독립성' 갖게 됨


## 6장. 함수형 프로그래밍
* 함수형은 '가변 변수'를 전혀 사용하지✖︎  
  ➢ 경합(race)조건, 교착 상태(dead lock) 조건, 동시 업데이트 (concurrent update) 문제 발생 가능성 ✖︎ </br>
    ⤷ '불변 컴포넌트' Level에서는 함수형 사용이 유리함

# 3부. 설계 원칙
SOLID 원칙
* 함수와 데이터 구조를 클래스로 배치하는 방향, 그리고 이들 클래스를 서로 결합하는 방법을 설명</br>
목적 1. 변경에 유연 2. 이해하기 쉽다. 3. 많은 소프트웨어 시스템에 사용 할 수 있는 컴포넌트의 기반이 된다.

## 7장. SRP: 단일 책임 원칙
* 하나의 모듈은 오직 하나의 사용자 또는 이해 관계자에 대해서만 책임져야 한다.</br>
   1액터 → 1 모듈

(그리이이이이이이이이이임 넣어야되에요오오오옹오)

## 8장. OCP: 개방-폐쇄 원칙
* 소프트웨어 개체의 행위는 확장 할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.
* 기능이 어떻게(how), 왜(why), 언제(when) 발생했는지에 따라 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화. </br>
⭐︎ 모든 컴포넌트는 단방향

(그리이이이이이이이이이임 넣어야되에요오오오옹오)

## 9장. LSP: 리스코프 치환 원칙
* 하위 타입이 변경되더라도 상위 코드에 영향✖︎

(그리이이이이이이이이이임 넣어야되에요오오오옹오)

## 10장. ISP: 인터페이스 분리 원칙

(그리이이이이이이이이이임 넣어야되에요오오오옹오)
## 11장. DIP: 의존성 역전 원칙
추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다.
반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 항상, 좀 더 정확히 말하면 대다수의 경우 변경될 필요가 없다.
따라서 인터페이스는 구현체보다 변동성이 낮다.

의존성 관리를 위해 추상 팩토리(Abstract Factory) 패턴 사용

(그리이이이이이이이이이임 넣어야되에요오오오옹오)


# 4부. 컴포넌트 원칙

## 12장. 컴포넌트
* 컴포넌트 : 
  * 배포 단위, 시스템의 구성 요소로 배포될 수 있는 가장 작은 단위.
  * 잘 설계된 컴포넌트는 반드시 독립적으로 배포가능함. 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.


## 13장. 컴포넌트 응집도
* 응집도와 관련된 3가지 원칙
  1. REP : 재사용 / 릴리즈 등가 원칙
     * 재사용 단위는 릴리즈(release) 단위와 같다.
     * 즉, 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함. 컴포넌트를 규정하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함.
  2. CCP : 공통 폐쇄 원칙
     * 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트를 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
     * 즉, 단일 컴포넌트는 변경의 이유가 여러개 있어서는 안된다.
  3. CRP : 공통 재사용 원칙
     * 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
     * 한 컴포넌트에 속한 클래스들을 더 작게 그룹지을 수 없다. 즉, 그 중 일부 클래스에만 의존되고 다른 클래스와는 독립적일 수 없음.
* 컴포넌트 응집도에 대한 균형 다이어그램
   * 프로젝트 초기 : CCP가 REP 보다 중요 → 시간이 지나면서 CRP, REP가 더 중요해짐
   * 즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변함


(그리이이이이이이이이이임 넣어야되에요오오오옹오)


## 14장. 컴포넌트 결합 
* 컴포넌트 사이의 관계를 설명하는 3가지 원칙
1. ADP : 의존성 비순환 원칙
  * 컴포넌트 의존성 그래프에 속한 cycle이 있어서는 안된다.
  * 순환 cycle 존재시 → 단위 테스트가 힘듬. 컴포넌트 분리가 어려움. 개발/빌드 어려움
  * 순환 끊기 방법 1. 의존성 역전원칙(DIP) 적용. 2. 새로운 컴포넌트 생성

2. SDP : 안정된 의존성 원칙
  * 안정성의 방향으로 (더 안정된 쪽에) 의존한다. (안정성 : 쉽게 움직이지 않는 상태)
  * SDP를 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

  * 안정성 지표
<pre>
    I(불안정성) = Fan out / (Fan in + Fan out)
      I = 0 : 최고로 안정된 컴포넌트 (변경이 쉽다)
      I = 1 : 최고로 불안정한 컴포넌트 (변경 어려움)

    Fan in : 안으로 들어오는 의존성. 내부 클래스에 의존하는 컴포넌트 외부의 클래스 갯수
    Fan out : 바깥으로 나가는 의존성. 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 갯수

</pre>
  * 컴포넌트 성격에 따라 I 값 위치 정해짐

3. AD(안정된 추상화 원칙)
 * 컴포넌트는 안정된 정도 만큼만 추산되어야 한다. → 안정성과 추상화 사이의 관계 정의

 * 추상화 정도 축정
 <pre>
     A = Na / Nc
       A = 0 : 추상 클래스가 하나도 없음
       A = 1 : 추상 클래스만 포함
     
     Na : 컴포넌트의 추상 클래스와 인터페이스의 개수
     Nc : 컴포넌트의 클래스 개수
 </pre>


(그리이이이이이이이이이임 넣어야되에요오오오옹오)

  * D거리 측정
  <pre>
     D 거리 = | A + I - 1 |
       0에 가까울 수록 주계열 근처.
  </pre>
  * 주계열 (Main Stream)에 위치한 것이 가장 안정적인 상태이다.



# 5부. 아키텍처

## 15장. 아키텍처란?
* 아키텍처의 목적 : 시스템의 생명주기를 지원하는 것
* 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수 하고, 또 쉽게 배포되개 해준다.
* 아키텍처의 궁극적 목표 : 시스템 수명에 대한 비용 최고화. 프로그래머의 생산성 최대화.

## 16장. 독립성
* 좋은 아키텍처는?
  * 시스템의 유즈 케이스 : 시스템의 아키텍처는 시스템의 의도를 지원 해야한다
  * 시스템의 운영 : 요구와 관련된 각 유즈케이스에 걸맞는 처리량과 응답시간을 보장해야 함
  * 시스템의 개발 : 각 개발팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해하지 않도록 해야 함
  * 시스템의 배포 : 시스템에 빌드 된 후 즉각 배포 할 수 있도록 지원해야 함
  * +++ 향 후 시스템 변경이 필요할 때 어떤 방향으로든 쉽게 변경 할 수 있어야 함

* 계층 설계 방법
  * '단일 책임 원칙' + '공통 폐쇄 원칙' ⇢ 서로 결합되지 않은 수평적인 계층으로 분리

* 유즈케이스 결합 분리
  * 시스템은 수평적 계층으로 분할 + 유즈케이스는 수직으로 분할. 단, 유즈케이스들이 각 계층에서 서로 겹치지 않아야 한다.


(그리이이이이이이이이이임 넣어야되에요오오오옹오)

## 17장. 경계: 선긋기
* 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하게 함

## 18장. 경계해부학

## 19장. 정책과 수준

## 20장. 업무규칙

## 21장. 소리치는 아키텍처

## 22장. 클린 아키텍처

## 23장. 프레젠터와 험블 객체

## 24장. 부분적 경계

## 25장. 계층과 경계

## 26장. 메인(Main) 컴포넌트

## 27장. '크고 작은 모든' 서비스들

## 28장. 테스트 경계

## 29장. 클린 임베디드 아키텍처

↑↓←→⇢⇢⇡⇣⇠✖︎✗✘✔︎✓➢▹▻➤⇧⍒⍋©⤷⭐︎ Control + Command + Spacebar
➢
https://unicode-table.com/kr/2937/
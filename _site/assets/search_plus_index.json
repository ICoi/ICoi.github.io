{"/jekyll-gitbook/others/about/": {
    "title": "About others",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/others/about/",
    "body": "This is an about page for “others” in the collections."
  },"/jekyll-gitbook/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/about/",
    "body": "This is an about page."
  },"/jekyll-gitbook/pages/contact/": {
    "title": "Contact",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/contact/",
    "body": "This is an contact page."
  },"/jekyll-gitbook/pages/design/draft/": {
    "title": "Design Draft",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/design/draft/",
    "body": "This is an draft page."
  },"/jekyll-gitbook/jekyll/2023-12-12-footnotes.html": {
    "title": "Using Footnotes",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2023-12-12-footnotes.html",
    "body": "This jekyll-theme supports MathJax to render footnotes in markdown. e.g., The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents[^1]. Meaning the next equation has no integer solutions: $$ x^n + y^n = z^n $$ The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents1. Meaning the next equation has no integer solutions: \\[x^n + y^n = z^n\\] Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem &#8617;"
  },"/jekyll-gitbook/jekyll/2023-10-14-math-latex.html": {
    "title": "MathJax and LaTeX",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2023-10-14-math-latex.html",
    "body": "This jekyll-theme supports MathJax to render $\\LaTeX$ and mathematics expressions. TIP Currently, Kramdown uses double dollar sign delimiters for inline and display math: https://kramdown.gettalong.org/syntax.html#math-blocks. e.g., The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents. Meaning the next equation has no integer solutions: $$ x^n + y^n = z^n $$ The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents. Meaning the next equation has no integer solutions: \\[x^n + y^n = z^n\\] Another example with more complex markups: When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are \\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\] Refer to the MathJax website for more examples."
  },"/jekyll-gitbook/jekyll/2023-08-31-mermaid.html": {
    "title": "Diagrams with mermaid.js",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2023-08-31-mermaid.html",
    "body": "This jekyll-theme supports mermaid.js to render diagrams in markdown. To enable the mermaid support, you need to set mermaid: true in the front matter of your post. --- title: Diagrams with mermaid.js date: 2023-08-31 layout: post mermaid: true --- Then you can use mermaid syntax in your markdown: graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; Or, even some complex examples: sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! Refer to the mermaid.js website for more examples."
  },"/jekyll-gitbook/jekyll/2022-06-30-tips_warnings_dangers.html": {
    "title": "Tips, Warnings, and Dangers",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-06-30-tips_warnings_dangers.html",
    "body": "This jekyll-theme supports tips, warnings, and dangers blocks and the style is referred from the discord.js website. You could have the following markdown attributes (supported by kramdown): Tips Using a {: .block-tip} attribute: &gt; ##### TIP &gt; &gt; This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have &gt; this or a similar version after installation. {: .block-tip } TIP This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have this or a similar version after installation. Warnings Using a {: .block-warning} attribute: &gt; ##### WARNING &gt; &gt; Be sure that you're familiar with things like async/await and object destructuring &gt; before continuing, as we'll be making use of features like these. {: .block-warning } WARNING Be sure that you’re familiar with things like async/await and object destructuring before continuing, as we’ll be making use of features like these. Dangers Using a {: .block-danger} attribute: &gt; ##### DANGER &gt; &gt; You cannot delete an ephemeral message. {: .block-danger } DANGER You cannot delete an ephemeral message."
  },"/jekyll-gitbook/jekyll/2022-06-26-wide_tables.html": {
    "title": "Wide tables",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-06-26-wide_tables.html",
    "body": "A wide tables needs to be wrapped into a div with class table-wrapper to make sure it displayed as expected on mobile devices. For example, &lt;div class=\"table-wrapper\" markdown=\"block\"&gt; |title1|title2|title3|title4|title5|title6|title7|title8| |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| &lt;/div&gt; Will be rendered as title1 title2 title3 title4 title5 title6 title7 title8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8"
  },"/jekyll-gitbook/jekyll/2022-05-24-page_cover.html": {
    "title": "Page with cover image",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-05-24-page_cover.html",
    "body": "The jekyll-gitbook theme supports adding a cover image to a specific page by adding a cover field to the page metadata: --- title: Page with cover image author: Tao He date: 2022-05-24 category: Jekyll layout: post + cover: /assets/jekyll-gitbook/dinosaur.gif ---"
  },"/jekyll-gitbook/2021-09-26-CleanArchitecture.html": {
    "title": "Book Review - Clean Architecture",
    "keywords": "CleanArchitecture BookReview",
    "url": "/jekyll-gitbook/2021-09-26-CleanArchitecture.html",
    "body": "책 리뷰 - Clean Architecture 이 글은 Clean Architecture 책의 내용 일부를 발췌하여 작성하였습니다. 자세한 설명 및 내용은 도서를 참고하시면 됩니다. 1부. 소개 1장 설계와 아키텍처란? 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는 데 있다. 투입 직원수↑ ➢ 생산성은 일정 수준에 수렴함 ➢ 투입 대비 생산성↓ ➢ 아키텍처 존재시 엉망으로 만들 때 보다 생산성↑ 2장 두가지 가치에 대한 이야기 가치 1. 행위(Behavior) 프로그래머는 이해 관계자가 기능 명세서나 요구사항 문서를 구체화 할 수 있도록 도움. 또한, 이러한 요구사항을 만족하도록 코드 작성. 가치 2. 아키텍처(Architecture) ‘소프트(Soft) 웨어’ - 기계의 행위를 Soft(쉽게) 변경 할 수 있어야 함 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는게 더 힘들어짐 아키텍처는 형태에 독립적이여야 하고, 그럴수록 더 실용적이다. 행위(Behavior) &lt; 아키텍처(Architecture) : 아키텍처가 후순위가 되면 시스템 개발비용↑, 혹은 기능변경이 불가능 해 질 수도 2부. 벽돌부터 시작하기: 프로그래밍 패러다임 3장. 패러다임 개요 패러다임이란? 프로그래밍을 하는 방법. 어떤 프로그래밍 구조를 사용할지, 언제 구조를 사용해야 하는지 결정 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 대해 규칙을 부과 (if/while과 같은 제어, 반복문 활용) 객체 지향 프로그래밍 : 제어흐름의 간접적인 전환에 대해 규칙을 부과 함수형 프로그래밍 : 할당문에 대해 규칙 부과 (변수 할당에 부과되는 규율) 패러다임은 무엇을 해야 할 지 보다는 무엇을 해서는 안되는지를 말해준다. 4장. 구조적 프로그래밍 * 분기, 반복(if, while)이라는 단순 제어 + 순차 실행 (sequential execution) ➢ 특별한 장점 ⍒ 복잡한 요구사항을 더 작은 기능 단위로 분해. 대규모 시스템 → 모듈과 컴포넌트 → 입증 할 수 있는 아주 작은 기능으로 세분화 ⍒ 테스트를 통해 버그가 없음을 증명 ➢ 안정적인 서비스 제공 5장. 객체지향 프로그래밍 OO(Object-Oriented) 본질 : 캡슐화, 상속, 다형성⭐︎ 다형성 &lt;/br&gt; ⤷ 의존성 역전(dependency inversion) : 소프트웨어 아키텍트는 시스템의 소스코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적 권한 갖게 됨 &lt;/br&gt; ⤷ 기능컴포넌트 독립을 통해 ‘배포 독립성’, ‘개발 독립성’ 갖게 됨 6장. 함수형 프로그래밍 함수형은 ‘가변 변수’를 전혀 사용하지✖︎ ➢ 경합(race)조건, 교착 상태(dead lock) 조건, 동시 업데이트 (concurrent update) 문제 발생 가능성 ✖︎ &lt;/br&gt; ⤷ ‘불변 컴포넌트’ Level에서는 함수형 사용이 유리함 3부. 설계 원칙 SOLID 원칙 함수와 데이터 구조를 클래스로 배치하는 방향, 그리고 이들 클래스를 서로 결합하는 방법을 설명&lt;/br&gt; 목적 1. 변경에 유연 2. 이해하기 쉽다. 3. 많은 소프트웨어 시스템에 사용 할 수 있는 컴포넌트의 기반이 된다. 7장. SRP: 단일 책임 원칙 하나의 모듈은 오직 하나의 사용자 또는 이해 관계자에 대해서만 책임져야 한다.&lt;/br&gt; 1액터 → 1 모듈 8장. OCP: 개방-폐쇄 원칙 소프트웨어 개체의 행위는 확장 할 수 있어야 하지만, 이때 개체를 변경해서는 안된다. 기능이 어떻게(how), 왜(why), 언제(when) 발생했는지에 따라 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화. &lt;/br&gt; ⭐︎ 모든 컴포넌트는 단방향 9장. LSP: 리스코프 치환 원칙 하위 타입이 변경되더라도 상위 코드에 영향✖︎ 10장. ISP: 인터페이스 분리 원칙 11장. DIP: 의존성 역전 원칙 추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 항상, 좀 더 정확히 말하면 대다수의 경우 변경될 필요가 없다. 따라서 인터페이스는 구현체보다 변동성이 낮다. 의존성 관리를 위해 추상 팩토리(Abstract Factory) 패턴 사용 4부. 컴포넌트 원칙 12장. 컴포넌트 컴포넌트 : 배포 단위, 시스템의 구성 요소로 배포될 수 있는 가장 작은 단위. 잘 설계된 컴포넌트는 반드시 독립적으로 배포가능함. 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다. 13장. 컴포넌트 응집도 응집도와 관련된 3가지 원칙 REP : 재사용 / 릴리즈 등가 원칙 재사용 단위는 릴리즈(release) 단위와 같다. 즉, 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함. 컴포넌트를 규정하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함. CCP : 공통 폐쇄 원칙 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트를 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라. 즉, 단일 컴포넌트는 변경의 이유가 여러개 있어서는 안된다. CRP : 공통 재사용 원칙 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라. 한 컴포넌트에 속한 클래스들을 더 작게 그룹지을 수 없다. 즉, 그 중 일부 클래스에만 의존되고 다른 클래스와는 독립적일 수 없음. 컴포넌트 응집도에 대한 균형 다이어그램 프로젝트 초기 : CCP가 REP 보다 중요 → 시간이 지나면서 CRP, REP가 더 중요해짐 즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변함 14장. 컴포넌트 결합 컴포넌트 사이의 관계를 설명하는 3가지 원칙 ADP : 의존성 비순환 원칙 컴포넌트 의존성 그래프에 속한 cycle이 있어서는 안된다. 순환 cycle 존재시 → 단위 테스트가 힘듬. 컴포넌트 분리가 어려움. 개발/빌드 어려움 순환 끊기 방법 1. 의존성 역전원칙(DIP) 적용. 2. 새로운 컴포넌트 생성 SDP : 안정된 의존성 원칙 안정성의 방향으로 (더 안정된 쪽에) 의존한다. (안정성 : 쉽게 움직이지 않는 상태) SDP를 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다. 안정성 지표 I(불안정성) = Fan out / (Fan in + Fan out) I = 0 : 최고로 안정된 컴포넌트 (변경이 쉽다) I = 1 : 최고로 불안정한 컴포넌트 (변경 어려움) Fan in : 안으로 들어오는 의존성. 내부 클래스에 의존하는 컴포넌트 외부의 클래스 갯수 Fan out : 바깥으로 나가는 의존성. 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 갯수 컴포넌트 성격에 따라 I 값 위치 정해짐 AD(안정된 추상화 원칙) 컴포넌트는 안정된 정도 만큼만 추산되어야 한다. → 안정성과 추상화 사이의 관계 정의 추상화 정도 축정 A = Na / Nc A = 0 : 추상 클래스가 하나도 없음 A = 1 : 추상 클래스만 포함 Na : 컴포넌트의 추상 클래스와 인터페이스의 개수 Nc : 컴포넌트의 클래스 개수 D거리 측정 D 거리 = | A + I - 1 | 0에 가까울 수록 주계열 근처. 주계열 (Main Stream)에 위치한 것이 가장 안정적인 상태이다. 5부. 아키텍처 15장. 아키텍처란? 아키텍처의 목적 : 시스템의 생명주기를 지원하는 것 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수 하고, 또 쉽게 배포되개 해준다. 아키텍처의 궁극적 목표 : 시스템 수명에 대한 비용 최고화. 프로그래머의 생산성 최대화. 16장. 독립성 좋은 아키텍처는? 시스템의 유즈 케이스 : 시스템의 아키텍처는 시스템의 의도를 지원 해야한다 시스템의 운영 : 요구와 관련된 각 유즈케이스에 걸맞는 처리량과 응답시간을 보장해야 함 시스템의 개발 : 각 개발팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해하지 않도록 해야 함 시스템의 배포 : 시스템에 빌드 된 후 즉각 배포 할 수 있도록 지원해야 함 +++ 향 후 시스템 변경이 필요할 때 어떤 방향으로든 쉽게 변경 할 수 있어야 함 계층 설계 방법 ‘단일 책임 원칙’ + ‘공통 폐쇄 원칙’ ⇢ 서로 결합되지 않은 수평적인 계층으로 분리 유즈케이스 결합 분리 시스템은 수평적 계층으로 분할 + 유즈케이스는 수직으로 분할. 단, 유즈케이스들이 각 계층에서 서로 겹치지 않아야 한다. 17장. 경계: 선긋기 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하게 함 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다 ➢ 의존성 역전 원칙, 안정된 추상화 원칙 응용&lt;/br&gt; 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치 18장. 경계해부학 경계 단위 : 아래로 갈수록 물리적으로 명확한 경계 생김 소스코드 단위 동적링크 라이브러리 단위 스레드 로컬 프로세스 서비스 1개 이상의 경계 전략 활용 19장. 정책과 수준 소프트웨어 시스템이란? 정책을 기술한 것 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다.&lt;/br&gt; 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다. ‘수준(Level)’ : ‘입력과 출력’까지의 거리 → 멀어질수록 고수준 20장. 업무규칙 업무규칙 : 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차 ‘엔티티(Entity)’ : 핵심 업무 데이터 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화 하는 것&lt;/br&gt; 엔티티 객체는 핵심 업무데이터를 직접 포함하거나 매우 쉽게 접근 할 수 있음&lt;/br&gt; 엔티티는 고 수준의 개념이다. ‘유즈케이스(Use Case)’ : 자동화된 시스템이 사용되는 방법 설명 자동화된 시스템이 사용되는 방법 설명 → Application에 특화된 업무 규칙 설명 입력데이터를 받아 출력 데이터를 생성. but 인터페이스에 의존 ✖︎ 유즈케이스는 저 수준의 개념이다. 저수준(유즈케이스) 개념은 고수준 (엔티티) 개념을 알고 있다. 고수준 (엔티티) 개념은 저수준 (유즈케이스) 개념을 모른다. 21장. 소리치는 아키텍처 웹은 아키텍처인가? NO! → 웹, 앱 등은 전달 메커니즘 (입출력 장치) 즉, 아키텍처는 View나 Controller가 아닌 Model을 설계 해야 함 22장. 클린 아키텍처 아키텍처의 목표 : ‘관심사의 분리’ 아키텍처는 모두 시스템의 다음과 같은 특징은 지니도록 만든다 프레임워크 독립성 테스트 용이성 UI 독립성 데이터베이스 독립성 모든 외부 에이전시에 대한 독립성 23장. 프레젠터와 험블 객체 행위 → 본질과 테스트하기 어려운 행위(험블객체)로 나눔 프레젠터와 뷰, 데이터베이스와 게이트웨이, 서비스 리스너와 인터페이스 경계에 험블 객체 패턴이 숨어있다 24장. 부분적 경계 코드 단위 분리 일차원 경계 Facade 패턴 활용 25장. 계층과 경계 26장. 메인(Main) 컴포넌트 메인 컴포넌트 ‘시스템의 초기 진입점’ 이 컴포넌트가 나머지 컴포넌트를 생성하고 조정하며 관리한다. &lt;/br&gt; → 의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 바로 메인 컴포넌트에서 이루어져야 함 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는 지저분한 저수준 모듈이라는 점. 메인은 고수준의 시스템을 위한 모든 것을 로드 한 후, 제어권을 고수준의 시스템에게 넘긴다. 27장. ‘크고 작은 모든’ 서비스들 28장. 테스트 경계 테스트는 아키텍처에서 가장 바깥쪽 원으로 생각 할 수 있다. 시스템 내부의 어떤 것도 테스트에는 의존하지 않으며, 테스트는 시스템이 컴포넌트를 향해 항상 원의 안쪽으로 의존한다. 또한 테스트는 독립적으로 배포 가능하다. 시스템과 테스트를 설계 할 때, GUI를 사용하지 않고 업무 규칙을 테스트 할 수 있게 해야한다. 29장. 클린 임베디드 아키텍처 (생략..)"
  },"/jekyll-gitbook/jekyll/2021-08-10-toc.html": {
    "title": "How to Generate TOC",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2021-08-10-toc.html",
    "body": "The jekyll-gitbook theme leverages jekyll-toc to generate the Contents for the page. The TOC feature is not enabled by default. To use the TOC feature, modify the TOC configuration in _config.yml: toc: enabled: true Why this repo long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8"
  },"/jekyll-gitbook/2021-03-28-SwiftPackageManager.html": {
    "title": "Swift Package Manager 활용 (1) 외부 라이브러리 의존성 관리",
    "keywords": "SwiftPackageManager SPM iOS Xcode",
    "url": "/jekyll-gitbook/2021-03-28-SwiftPackageManager.html",
    "body": "Swift Package Manager 활용 (1) 외부 라이브러리 의존성 관리 Swift Package Manager(이하, SPM) 란? Swift로 작성된 코드의 Package의 배포, 적용 및 의존성을 관리하는 Manager로 활용되는 기능으로 설명하자면 아래와 같다. CocoaPods을 대체하는 기능을 제공 Swift로 작성된 코드들의 프로젝트를 대신함 (Xcode Project를 대신함) 해당 글에선 언급된 기능 중 1번 CcoaPods을 대체하는 의존성 관리 측면에서 활용한 내용에 대해 작성하며, 2번에 해당하는 프로젝트 대신하는 기능은 언젠가 작성할 예정입니다. 과거의 외부 라이브러리 의존성 관리는? 외부 라이브러리를 다운받고, 해당 라이브러리 적용에 필요한 설정들을 자동으로 적용하고, 외부 라이브러리 버전 업데이트 하는 모든 복잡한 과정을 CocoaPods을 활용하여 관리를 하는 것이 일반적이었다. 과거 수동으로 진행하던 것에 비하면 CocoaPods를 사용하는 것은 확실히 편리하긴 했지만 굳이 단점이라면 pod install과 같은 명령어를 프로젝트 외부에서 수행해야한다는 것과, XCodeProject 가 아닌 xcworkspace 확장자를 가지는 워크스페이스를 사용해야만 한다는 점… Apple에서 정식으로 제공되는 프로그램이 아니다보니 어쩔 수 없이 Xcode 외부에 별도의 설치 및 수행 과정을 거치는 아주 소소한 번거로움이 있다. SPM 도입 이유? 이번 친구들과 개발하는 프로젝트에는 CocoaPods 대신 SPM을 활용하기로 했다. 그 이유는 거창한 무엇도 아닌 외부 프로그램 설치를 안해도 되고, XCode 내에서 할 수 있다는 점. 그리고 회사에서는 못해볼거 같아서..? SPM 활용 방법 SPM 활용 방법은 매우매우매우 쉽다. 외부 라이브러리의 저장소 URL을 확인합니다. ex) Alamofire의 경우 github 주소인 https://github.com/Alamofire/Alamofire Xcode 메뉴에서 File -&gt; Swift Packages -&gt; Ad Package Dependency… 메뉴 선택 3-1. 가져올 라이브러리의 저장소 URL을 입력 후 Next 3-2. 적용할 외부 라이브러리의 버전, 브랜치 명 혹은 커밋 해쉬값을 입력 후 Next 3-3. 실제 프로젝트에서 필요한 라이브러리만 선택 한 뒤 Next 혹시 추가한 라이브러리들을 제거 하거나 버전 편집이 필요하면 Project 타겟 선택 후 info 의 Package 항목에서 편집 및 삭제가 가능하다. SPM 사용 후기 SPM 을 활용하는 것은 걱정 이상으로 너무 쉽고 간편했다. 평소 프로그램 설치시마다 남들은 겪지 않는 온갖 문제를 겪어 오는지라 무언가 설치 하는 것에 두려움이 있는데, 항상 사용하던 XCode 내에서 쉽고 편하게 할 수 있으니… 앞으로 다시는 CocoaPods으로 되돌아가지 않을것 같다는.. 다음 과제 라이브러리를 제작하여 SPM을 통해 배포해보기."
  },"/jekyll-gitbook/2020-12-26-Review2020.html": {
    "title": "2020년 회고",
    "keywords": "Review 2020",
    "url": "/jekyll-gitbook/2020-12-26-Review2020.html",
    "body": "2020 회고 서문 스터디를 함께하는 친구의 제안으로 이 특별한 시점까지 열심히 달려온 내 자신을 되돌아 보고 칭찬해주는 회고를 진행하려고 합니다. 회고 파티를 회고해준 Pineoc의 글은 링크를 통해 확인 가능합니다. 회고를 시작하기 전에.. 2020년은 돈 버는 개발자가 된지 만 5년이 되는 여러가지로 특별한 한해입니다. 과거 3~4년 주기로 항상 새로운 단계를 겪어왔습니다. 학교를 진급하거나, 동아리 활동 등을 진행하면서 매 단계마다 새로운 환경에서 짧고 굵게 최선을 다하고 그 결과물을 얻어 내는 단거리 경주에 익숙해왔습니다. 하지만 과거와는 달리 열심히 달려왔지만 직장인 신분은 끝이 없다고 느껴집니다. 4년차가 지나 5년차가 되서야 내가 있는 이 곳이 기존과 다름을 깨달았습니다. 끝이 없는 이 길에서 단거리 경기에 익숙한 내가 장거리 경기를 달리기 위하여 새로 수립해야할 전략은 무엇일지 그 답을 신기하게도 회고를 진행하면서 발견하였습니다. 몰아쓰는 나의 2020년 일기는 올해 진행하였던 회사와 개인적으로 진행한 일들에 대해 평가하고, 이를 바탕으로 내년에 나아가야할 방향에 대해 정리하려고 합니다. 2020년 현재 내 상태 경력 및 업무 2015년 12월 신입 공채 입사 후 무려 5년 (12월 14일 기준으로 딱 5년)이나 다닌 고인물 주업무 모바일 게임 SDK 신규버전 iOS 유지보수 신규 프로젝트에 iOS 개발 담당 진행 중 보조 업무 Android 유지보수 서포트 모바일 게임 SDK Unity 엔진 플러그인 유지보수 업무 환경 개선 업무 진행 그 외 대학시절부터 같이 프로젝트 하던 친구들과 6개월째 스터디(라 쓰고 각자 공부) 진행 중 익숙함 속에서 새로운 도전을 시도하는 중 2020년 평가 2020년 잘한일 팀 내 개발 편의를 위한 개발 환경 개선 진행 샘플 빌드 자동화 환경을 구축, 외부 라이브러리 참조 방식 변경, XCodeGen 도입 누가 시킨 일은 아니였으나 스스로 작업 환경을 개선하고자 업무 틈틈히 진행하였으며 팀 내 개발 환경을 개선하는 밑거름이 됨 신규 프로젝트 자원하여 참여 Milestone 1 을 겨우 진행한 초기 단계라 개발 성과는 없지만, 새로운 도전을 시도하였다는 점에서 Good! ‘유지보수’업무에서 벗어나 처음으로 0에서 부터 시작하는 개발을 진행하여 과정에서 기존에 겪지 못했던 새로운 경험을 할 것으로 기대됨 iOS 14 대응 및 Apple Silicon (M1) Chip 환경 대응 WWDC 2020 및 개발자 포럼을 참고하여 iOS 14의 신규, 변경 내용에 대해 정리 및 제안 Apple Silicon (M1) Chip이 포함된 PC 환경과 기존 iOS 환경의 공통점과 차이점에 대해 파악하고, 환경에 맞는 개발 방향 제안 단순히 새로움을 보는 것이 아니라 기술을 탐구하고 이를 바탕으로 개발 방향을 제안 하며 기술 시야를 넓힌 계기가 됨 2020년 열심히 했지만 아쉬웠던 일 모듈화 하는 작업 진행 잘한일 서비스 모듈화 설계 및 작업 진행 아쉬운 점 모듈간 호출 로직 및 함수 공개 범위 등에 대한 고민이 부족 (개발 설계 역량 부족) 회사 업무 (SDK 유지보수) 잘한일 작업한 내용 중 버그 발생 건수가 확연하게 줄어듬 iOS 특성에 맞는 개발 방향 제안 및 기존의 기능 개선 방법 고민 진행 아쉬운 점 유지보수를 위한 설계등이 선행된 개발을 진행하지 못한 아쉬움 존재 코드 리펙토링 및 개선 필요한 부분을 외면함… 메모리 누수, 멀티 스레드 환경 등 개발 안정성에 대한 고민 부족 주력 언어 변경 (ObjectiveC -&gt; Swift) 잘한일 Swift의 기본 문법 및 사용에 익숙해짐 아쉬운 점 Swift 언어 특성에 맞는 개발 설계는 미숙 (Protocol 활용 등) 친구들과 하는 스터디 내가 진행한 공부 “GoF디자인 패턴” 책 : 자주 쓰이는 패턴 일부에 대한 학습 진행 RxSwift : RxSwift의 개념에 대한 공부 진행 잘한일 지속적으로 참여하였음 비슷한 분야에 종사하는 친구들의 이야기를 통해 간접 경험 획득 아쉬운 점 깊이있는 공부를 진행하지 못한 아쉬움 공부한 내용을 정리하는 시간을 가지지 못한 것에 대한 아쉬움 2020년 부족했던 일 (못한일) CI/CD를 CI/CD답게 사용해보고 싶었음 테스트 자동화 환경을 구축해보고 싶었으나 못함 (능력 부족) CI/CD를 직접 유지 보수 해보고 싶었으나 못함 그 외 여러가지로 CI/CD를 활용해보고 싶었으나 못함 개인 프로젝트 가지기 회사내에선 다양한 이해관계로 인해 하지 못하는 작업들을 테스트 해볼 수 있는 개인 프로젝트를 가지고 싶었으나 못함 (의지 부족, 아이디어 부족) 회고 정리 2020년 총평 2020년의 나는 회사에서의 ‘일’은 잘 하였지만, ‘일’을 잘 하기보단 일을 ‘잘’하는 사람이 되고 싶어했던 사람. 회고록을 작성하다보니 공통점이 보였습니다. 일을 수행하는 것들에 대해서는 대체적으로 만족한 편이었으며, 그 와중에 새로운 시도도 끊임없이 해왔습니다. 다만, 개발 설계, 안정성 등 단순히 주어진 일을 하는 것 외에 개발을 ‘잘’하는 방법에 대한 부분은 대체적으로 부정적인 피드백을 작성하였습니다. 그래서 내년의 나는..? 당장의 목표를 달성하기 위해 일을 하기보다는, 장기적인 관점에서 유지보수를 용이하게 하기 위한 코드 설계와 프로그램을 안정적으로 구현하기 위한 기초 동작 방식 고민에 대한 공부가 필요함 내년의 나는 새로운 서비스를 만들기보단 좀 더 이론적이고 근본적인 기술 탐구에 집중해볼까 합니다. 내가 가진 습관에서 벗어나 다양한 사람들의 생각과 개발방향을 경험해 보고, 그들의 방법을 익혀 적용해보는 시간을 가져볼까 합니다. 사람들을 일일히 만나서 배우는 것에는 현실적인 한계가 있으므로, 다양한 개발자들의 코드가 있는 Github을 여행해보는 것을 최종 목표로 정하였습니다."
  },"/jekyll-gitbook/2020-08-30-RxSwift1.html": {
    "title": "RxSwift 1.ReactiveX란?",
    "keywords": "RxSwift iOS",
    "url": "/jekyll-gitbook/2020-08-30-RxSwift1.html",
    "body": "ReactiveX란 무엇인가 ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences. ReactiveX는 observable한 시퀀스를 이용해서 비동기의 이벤트 기반의 프로그램을 구성하는 라이브러리이다. 출처 : ReactiveX 공식 홈페이지 ReactiveX 혹은 Rx는 Reactive eXtension의 줄임말로, 반응형 (Reactive) 프로그래밍을 쉽게 사용할 수 있도록 확장(extension) 제공되는 라이브러리입니다. Rx는 데이터와 이벤트들의 흐름(sequence)를 지원하기 위해 observer pattern을 활용하였습니다. Observer pattern에서 사용되는 구독(Subscribe) 개념이 Rx에서도 유사하게 도입되어 있습니다. 또한, Rx는 선언형 (declarative) 패러다임을 차용하고 있습니다. 프로그래밍시 스레드 관리, 동기화, 스레드 동시 접근 제어, 병렬 데이터 구조나 비동기 처리와 같은 복잡한 로직 걱정 없이 스퀀스들이 무엇을 하게 할지를 제공되는 명령어(operators)를 이용하여 개발합니다. Rx를 함수형 반응형 프로그래밍(Functional reactive programming) 으로 오해하는 경우가 있는데, Rx는 함수형(Functional)이고 반응형(reactive) 패러다임을 지향하지만 함수형 반응형 프로그래밍(Functional reactive programming)은 아닙니다. 함수형 반응형 프로그래밍(Functional reactive programming)은 값을 지속적으로(continuously) 처리해야하지만, Rx의 함수들은 프로그램이 진행되면서 전달(emit)되는 연속적이지 않은 값(discrete values)들을 처리합니다. 즉, ReactiveX는 함수형, 반응형 패러다임을 제공하는 비동기 기반 이벤트를 효율적으로 처리하기 위해 도입된 라이브러리입니다. Observables를 활용하는 이유 (Why use observables?) Rx의 Observable model은 단순한 비동기 이벤트들의 흐름이나, array와 같은 자료구조(collections)들을 다루는 연산자들을 다루기 쉽게 합니다. 복잡한 콜백들 사용을 대체하여 읽기 쉽고 잠재적인 버그 발생의 위험을 줄여줍니다. Observables는 구성하기 쉽다(Observables are composable) 비동기 작업을 하는 경우 main thread 의 동작에 제한이 가지 않도록 thread를 생성하여 동작을 제어해야하는 복잡함이 있습니다. 해당 문제를 쉽게 사용하기 위해 Java의 Future를 이용하여 비슷한 상황에서 활용 할 수 있으나, Future는 비동기를 중첩적으로 사용하는 경우에는 적합하지 못하다. Rx의 Observerbles을 이용하면 복잡한 비동기 데이터 흐름과 시퀀스(sequence)를 쉽게 작업 할 수 있습니다. Observable은 유연하게 활용 할 수 있다(Obervables are flexible) Java의 Future가 단일 값(single scalar values)의 발생에 대한 처리만 가능한 것 과는 달리 Rx의 Observables는 단일 값의 발생 뿐 아니라 데이터 시퀀스(sequence)나 무한하게 전달되는 값에 대한 처리도 가능합니다. Observables은 구현 방식에 의존적이지 않다(Observables are less opinionated) Rx는 동시성 또는 비동기 상황에 관계 없이 사용 가능합니다. Observables은 thread-pools, event loops, non-blocking I/O, actors, 혹은 당신의 코드 스타일이나 방식을 활용하여 구현 될 수 있습니다. 비동기 환경, blocking이나 non-blocking 혹은 필요한 방식 대로 구현 하도록 활용 할 수 있습니다. Callbacks은 중첩된 비동기 구문에서 사용이 적합하지 않다(Callbacks have their own problems) Callback은 그 무엇도 block 상태에 빠지지 않도록 하여 Future.get는 작업이 완료 될 때 까지 blocking되는 문제를 해소하였습니다. Callback을 이용하면 응답이 준비 될 때 실행되므로 효율적입니다. 그러나, Future와 마찬가지로 단순한 비동기 구문 (single level of asynchronous)을 실행할때는 쉽게 사용 할 수 있으나, 중첩된 비동기 구조에서는 사용이 복잡합니다. Rx는 많은 언어를 통해 제공된다 (ReactiveX is a polyglot implementation) Rx는 다양한 언어를 이용해서, 그들의 표현 양식(idiom)에 맞게 사용 할 수 있도록 제공되고 있습니다. Reactive Programming 패러다임 Rx는 반응형 프로그래밍(Reactive Programming) 패러다임을 따르고 있습니다. 반응형 프로그래밍이란? Reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change. With this paradigm it is possible to express static (e.g., arrays) or dynamic (e.g., event emitters) data streams with ease, and also communicate that an inferred dependency within the associated execution model exists, which facilitates the automatic propagation of the changed data flow. 반응형 프로그래밍이란 데이터의 흐름과 변경을 추적하는 것과 관련된 선언형 프로그래밍 패러다임이다. 이 패러다임은 정적 혹은 동적인 데이터의 흐름을 쉽게 표현할 수 있으며, 데이터 흐름의 변화를 자동으로 추적 가능하게 하기 위해서 관련된 실행 모델간의 의존성을 연결한다. 출처 : 위키피디아-Reactive programming 위의 인용문과 같이 반응형 프로그래밍은 데이터의 흐름을 중심으로 하는 선언형 프로그래밍입니다. 데이터의 입력 혹은 변화가 발생하는 경우 무엇(What)을 할지를 작성하는데 중점을 두고 있으며, 비동기 상황에서 데이터의 변화에 따른 동작을 쉽게 대응 할 수 있다는 특징을 가지고 있습니다. 출처 ReactiveX 공식홈페이지"
  },"/jekyll-gitbook/2020-08-30-RxSwift0.html": {
    "title": "RxSwift 0.들어가기 전에",
    "keywords": "RxSwift iOS",
    "url": "/jekyll-gitbook/2020-08-30-RxSwift0.html",
    "body": "들어가기 전에 ReactiveX를 이해하기 위해서는 먼저 프로그래밍 패러다임 (Programming Paradigm)에 대해 이해햐여야 합니다. 프로그래밍 패러다임 (Programming Paradigm) 프로그래밍 패러다임의 개념 프로그래밍 패러다임의 정의를 찾아보면 아래와 같습니다. Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms. 프로그래밍 패러다임이란 각 언어가 가지는 특징에 맞게 프로그래밍 언어를 분류하는 일종의 방법론이다. 언어는 여러개의 패러다임으로 분류 될 수 있다. 출처 : 위키피디아 프로그래밍 패러다임이란 일종의 이론적인 방법론이며, 객체 지향 프로그래밍 (Objective Oriented Programming), 함수형 프로그래밍 (Functional Programming) 과 같은 것들이 모두 프로그래밍 패러다임 중 하나입니다. 과거, 1개의 언어는 1개의 특징적인 패러다임을 기반으로 설계된 것과 달리 최근에 만들어진 프로그래밍 언어는 다양한 패러다임(Multi-paradigm) 개념을 기반으로 프로그래밍 될 수 있도록 설계되고 있습니다. Swift도 프로토콜 지향(protocol-oriented), 객체 지향 (object-oriented), 함수형 (functional), 명령형 (imperative), 선언형 (declarative) 패러다임의 개념을 포함하는 Muti-Paradigm 언어입니다. 프로그래밍 패러다임의 종류 프로그래밍 패러다임은 크게 명령형(imperative) 와 선언형(declarative)으로 분류되며, 절차 지향 (procedural), 객체 지향 (object-oriented), 함수형(functional), 논리(logic) 등의 패러다임들도 세분화 됩니다. 명령형(imperative) 프로그래밍 명령형 프로그래밍이란 상태를 변경하는 구문의 관점에서 연산을 작성하는 패러다임입니다. 어떻게 (How) 동작할지를 작성하며, 알고리즘 등을 활용하여 구체적인 문제 해결 방법을 프로그래밍합니다. 절차 지향 프로그래밍, 객체 지향 프로그래밍 등이 명령형 프로그래밍에 속합니다. 절차 지향 (procedural) 프로그래밍 어떠한 문제를 해결하기 위한 계산 과정(명령어)을 순차적으로 작성하는 패러다임입니다. 명령형 프로그래밍과 동의어로 쓰이는 경우가 있습니다. ex) C 객체 지향 (object-oriented) 프로그래밍 프로그램을 명령어의 흐름이 아닌 ‘객체’라는 기본 단위로 나누고, 객체들의 상호작용을 서술하는 프로그래밍 패러다임입니다. ex) C++, JAVA 선언형(declarative) 프로그래밍 선언형 프로그래밍은 해결방법이 아닌 수행하고자 아는 동작을 작성하는 패러다임입니다. 무엇 (What)을 할지에 대해 작성합니다. 함수형 프로그래밍, 논리형 프로그래밍 등이 선언형 프로그래밍에 속합니다. 선언형 쿼리 언어(Declarative Query Language)인 SQL, HTML도 선언형 프로그래밍 패러다임을 기반으로 합니다. 함수형 (functional) 프로그래밍 함수형 프로그래밍이란 순수함수로 구성하여 프로그래밍을 하는 패러다임입니다. 순수함수란 동일한 인자값을 넣는다면 항상 동일한 리턴 값을 반환하며, 외부의 상태나 데이터 등에 영향을 받지 않는 함수를 의미합니다. ex) LISP 컴퓨터 프로그램을 활용하여 수학 표기법을 나타내기 위한 목적으로 만들어진 언어입니다. 함수 f가 a,b,c라는 세개의 피연산자를 가진 함수 호출은 (f a b c)로 표현하는 문법 형식을 가지고 있습니다. (+ 1 2) -&gt; 결과 : 3 (+ 3 4) -&gt; 결과 : 7 논리형 (logic) 프로그래밍 논리 문장을 이용하여 프로그램을 표현하고 계산을 수행하는 패러다임입니다. ex) prolog prolog는 프랑스 마르세이유 대학 인공지능연구실에서 개발된 언어로, 인공지능이나 계산 언어학 혹은 자연어 처리에 많이 사용됩니다. prolog 프로그래밍은 사실들과 규칙들로 이루어져 있고, 이것을 이용하여 대답을 도출해냅니다. 규칙) A가 B를 좋아한다는 것은 like(A,B) 로 표현한다 사실 1) like(Jonh, Mary) 사실 2) like(Mary, Bill) 질문 ) ?-like(Bill, Mary) 결과 ) NO (거짓) 질문 ) ?-like(Jonh, Mary) 결과 ) YES (참) 명령형 프로그래밍 vs 선언형 프로그래밍 You know imperative programming is like HOW you do something, and declarative programming is more like WHAT you do, or something. 명령형 프로그래밍은 “어떻게” 할지를 프로그래밍하고, 선언형 프로그래밍은 “무엇”을 할지를 프로그래밍한다. 출처 : Imperative vs Declarative Programming 집으로 가는 방법을 프로그래밍을 한다고 하면 아래와 같은 차이가 나타납니다. 명령형 프로그래밍 지하철 1호선을 타고 A역으로 간다.. A역에서 내려서 1번 출구로 간다. 출구에서 200m 직진 후 우회전 하여 골목으로 들어간다. 골목에서 우측에 3번째 건물로 들어가서 3층 30x호로 간다. 선언형 프로그래밍 집 주소는 서울특별시 영등포구 X동 000-0번지, 30x호이다. 명령형 프로그래밍은 알고리즘 등을 활용하여 원하는 동작을 수행하기 위한 절차를 수행한다면, 선언형 프로그래밍은 최종적으로 원하는 목표를 명시합니다. 자료 출처 위키피디아-Programming paradigm 위키피디아-swift 위키피디아-절차적 프로그래밍 나무위키 - 객체 지향 프로그래밍 위키백과-논리형 프로그래밍 다양한 프로그래밍 패러다임 - 명령형, 절차지향, 선언형, 함수형, 논리형, 객체지향 명령형 프로그래밍 VS 선언형 프로그래밍 인공지능언어 PROLOG 위키백과-리스프"
  },"/jekyll-gitbook/jekyll/2019-04-29-license.html": {
    "title": "License",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-29-license.html",
    "body": "This work is open sourced under the Apache License, Version 2.0, using the same license as the original GitBook repository. Copyright 2019 Tao He."
  },"/jekyll-gitbook/jekyll/2019-04-28-howto.html": {
    "title": "How to Get Started",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-28-howto.html",
    "body": "The jekyll-gitbook theme can be used just as other Jekyll themes and support remote theme on Github Pages, see the official guide as well. You can introduce this jekyll theme into your own site by either Fork this repository and add your markdown posts to the _posts folder, then push to your own Github repository. Use as a remote theme in your _config.yml(just like what we do for this site itself), # Configurations title: Jekyll Gitbook longtitle: Jekyll Gitbook remote_theme: sighingnow/jekyll-gitbook TIP No need to push generated HTML bundle."
  },"/jekyll-gitbook/jekyll/2019-04-27-why.html": {
    "title": "Why Jekyll with GitBook",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-27-why.html",
    "body": "GitBook is an amazing frontend style to present and organize contents (such as book chapters and blogs) on Web. The typical to deploy GitBook at Github Pages is building HTML files locally and then push to Github repository, usually to the gh-pages branch. However, it’s quite annoying to repeat such workload and make it hard for people do version control via git for when there are generated HTML files to be staged in and out. This theme takes style definition out of generated GitBook site and provided the template for Jekyll to rendering markdown documents to HTML, thus the whole site can be deployed to Github Pages without generating and uploading HTML bundle every time when there are changes to the original repository."
  }}
